package main

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/otto-nation/otto-stack/internal/config"
	pkgConfig "github.com/otto-nation/otto-stack/internal/pkg/config"
	"gopkg.in/yaml.v3"
)

func main() {
	// Load commands.yaml from embedded data
	data := config.EmbeddedCommandsYAML

	var commandConfig pkgConfig.CommandConfig
	if err := yaml.Unmarshal(data, &commandConfig); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse commands.yaml: %v\n", err)
		os.Exit(1)
	}

	// Group commands by handler
	handlerCommands := make(map[string][]string)
	for cmdName, cmd := range commandConfig.Commands {
		if cmd.Handler != "" {
			handlerCommands[cmd.Handler] = append(handlerCommands[cmd.Handler], cmdName)
		}
	}

	// Generate register.go for each handler
	for handler, commands := range handlerCommands {
		sort.Strings(commands)
		generateRegisterFile(handler, commands)
	}

	fmt.Printf("Generated register.go files for %d handlers\n", len(handlerCommands))
}

func generateRegisterFile(handler string, commands []string) {
	outputPath := fmt.Sprintf("internal/pkg/cli/handlers/%s/register_generated.go", handler)

	file, err := os.Create(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create %s: %v\n", outputPath, err)
		return
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			fmt.Fprintf(os.Stderr, "Failed to close file: %v\n", closeErr)
		}
	}()

	// Generate Go code
	_, _ = fmt.Fprintln(file, "// Code generated by cmd/generate-registers. DO NOT EDIT.")
	_, _ = fmt.Fprintln(file)
	_, _ = fmt.Fprintf(file, "package %s\n", handler)
	_, _ = fmt.Fprintln(file)
	_, _ = fmt.Fprintln(file, "import (")
	_, _ = fmt.Fprintln(file, "\t\"github.com/otto-nation/otto-stack/internal/pkg/cli/handlers\"")
	_, _ = fmt.Fprintln(file, "\tcliTypes \"github.com/otto-nation/otto-stack/internal/pkg/cli/types\"")
	_, _ = fmt.Fprintln(file, ")")
	_, _ = fmt.Fprintln(file)

	// Generate handler map
	_, _ = fmt.Fprintf(file, "var %sHandlers = map[string]func() cliTypes.CommandHandler{\n", handler)
	for _, cmd := range commands {
		handlerCall := "New" + toPascalCase(cmd) + "Handler"
		_, _ = fmt.Fprintf(file, "\t%q: func() cliTypes.CommandHandler { return %s() },\n", cmd, handlerCall)
	}
	_, _ = fmt.Fprintln(file, "}")
	_, _ = fmt.Fprintln(file)

	// Generate init function
	_, _ = fmt.Fprintln(file, "func init() {")
	_, _ = fmt.Fprintf(file, "\thandlers.Register(%q, func(name string) cliTypes.CommandHandler {\n", handler)
	_, _ = fmt.Fprintf(file, "\t\tif factory, exists := %sHandlers[name]; exists {\n", handler)
	_, _ = fmt.Fprintln(file, "\t\t\treturn factory()")
	_, _ = fmt.Fprintln(file, "\t\t}")
	_, _ = fmt.Fprintln(file, "\t\treturn nil")
	_, _ = fmt.Fprintln(file, "\t})")
	_, _ = fmt.Fprintln(file, "}")

	fmt.Printf("Generated %s with %d commands\n", outputPath, len(commands))
}

// toPascalCase converts kebab-case to PascalCase
func toPascalCase(s string) string {
	parts := strings.Split(s, "-")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return strings.Join(parts, "")
}
