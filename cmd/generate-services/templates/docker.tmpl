// Code generated by generate-services. DO NOT EDIT.
package docker

import (
	"github.com/otto-nation/otto-stack/internal/config"
	"gopkg.in/yaml.v3"
)

// InitServiceSpec represents the init service configuration from service YAML
type InitServiceSpec struct {
	Enabled          bool              `yaml:"enabled,omitempty"`
	Mode             string            `yaml:"mode,omitempty"`
	Image            string            `yaml:"image,omitempty"`
	Environment      map[string]string `yaml:"environment,omitempty"`
	Scripts          []InitScript      `yaml:"scripts,omitempty"`
	DependsOnService bool              `yaml:"depends_on_service,omitempty"`
	Timeout          string            `yaml:"timeout,omitempty"`
}

// InitScript represents a script to execute in the init service
type InitScript struct {
	Content string `yaml:"content"`
}

// Script type constants
const (
	InitScriptTypeShell        = "shell"
	InitScriptTypeSQL          = "sql"
	InitScriptTypeAWSResources = "aws_resources"
	InitScriptTypeKafkaTopics  = "kafka_topics"
	InitScriptTypeHTTPRequests = "http_requests"
)

// ServiceCharacteristicsConfig defines Docker behaviors for service characteristics
type ServiceCharacteristicsConfig struct {
	ServiceCharacteristics map[string]ServiceCharacteristic `yaml:"service_characteristics"`
}

// ServiceCharacteristic defines flags for different Docker operations
type ServiceCharacteristic struct {
	ComposeUpFlags   []string `yaml:"compose_up_flags"`
	ComposeDownFlags []string `yaml:"compose_down_flags"`
	RunFlags         []string `yaml:"run_flags"`
}

// ServiceCharacteristicsResolver resolves Docker flags based on service characteristics
type ServiceCharacteristicsResolver struct {
	config *ServiceCharacteristicsConfig
}

// NewServiceCharacteristicsResolver creates a new service characteristics resolver
func NewServiceCharacteristicsResolver() (*ServiceCharacteristicsResolver, error) {
	serviceConfig, err := loadServiceCharacteristicsConfig()
	if err != nil {
		return nil, err
	}

	return &ServiceCharacteristicsResolver{
		config: serviceConfig,
	}, nil
}

// ResolveComposeUpFlags resolves flags for compose up based on service characteristics
func (scr *ServiceCharacteristicsResolver) ResolveComposeUpFlags(characteristics []string) []string {
	flags := []string{}

	// Add characteristic-based flags
	for _, characteristic := range characteristics {
		if serviceChar, exists := scr.config.ServiceCharacteristics[characteristic]; exists {
			flags = append(flags, serviceChar.ComposeUpFlags...)
		}
	}

	return flags
}

// ResolveComposeDownFlags resolves flags for compose down based on service characteristics
func (scr *ServiceCharacteristicsResolver) ResolveComposeDownFlags(characteristics []string) []string {
	flags := []string{}

	// Add characteristic-based flags
	for _, characteristic := range characteristics {
		if serviceChar, exists := scr.config.ServiceCharacteristics[characteristic]; exists {
			flags = append(flags, serviceChar.ComposeDownFlags...)
		}
	}

	return flags
}

// loadServiceCharacteristicsConfig loads the service characteristics configuration
func loadServiceCharacteristicsConfig() (*ServiceCharacteristicsConfig, error) {
	var serviceConfig ServiceCharacteristicsConfig
	if err := yaml.Unmarshal(config.EmbeddedServiceCharacteristicsYAML, &serviceConfig); err != nil {
		return nil, err
	}
	return &serviceConfig, nil
}