// Code generated by cmd/generate-cli. DO NOT EDIT.

package cli_test

import (
	"os"
	"strings"
	"testing"
)

// TestAllFlagsAreImplemented ensures every flag defined in commands.yaml
// is actually used in the corresponding handler code.
// This test is auto-generated to prevent flags from being documented but not implemented.
func TestAllFlagsAreImplemented(t *testing.T) {
	// Map of command to handler file and flags that must be used
	commandFlags := map[string]struct {
		handlerPath string
		flags       []string
	}{
{{- range .Commands}}
{{- if .Flags}}
		"{{.Name}}": {
			handlerPath: "{{.HandlerPath}}",
			flags: []string{
{{- range .Flags}}
				"{{.}}",
{{- end}}
			},
		},
{{- end}}
{{- end}}
	}

	for cmdName, info := range commandFlags {
		t.Run(cmdName, func(t *testing.T) {
			// Read handler file
			handlerCode, err := os.ReadFile(info.handlerPath)
			if err != nil {
				t.Skipf("Handler file not found: %s", info.handlerPath)
				return
			}

			code := string(handlerCode)

			// Check each flag is used
			for _, flagName := range info.flags {
				if !isFlagUsedInCode(code, flagName, cmdName) {
					t.Errorf("Flag '%s' defined in commands.yaml but not used in handler", flagName)
				}
			}
		})
	}
}

func isFlagUsedInCode(code, flagName, cmdName string) bool {
	// Check for Parse*Flags usage (preferred pattern)
	parseFuncName := "Parse" + strings.Title(cmdName) + "Flags"
	if strings.Contains(code, parseFuncName) {
		// Using generated parser - assume all flags in struct are used
		return true
	}

	// Check for direct flag access patterns
	pascalFlag := toPascalCase(flagName)
	patterns := []string{
		`GetBool("` + flagName + `")`,
		`GetString("` + flagName + `")`,
		`GetInt("` + flagName + `")`,
		`GetBool(core.Flag` + pascalFlag + `)`,
		`GetString(core.Flag` + pascalFlag + `)`,
		`GetInt(core.Flag` + pascalFlag + `)`,
		`.` + pascalFlag, // Struct field access
	}

	for _, pattern := range patterns {
		if strings.Contains(code, pattern) {
			return true
		}
	}

	return false
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "-")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
