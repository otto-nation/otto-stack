// Code generated by cmd/generate-cli. DO NOT EDIT.

package cli_test

import (
	"os"
	"strings"
	"testing"
)

// TestAllFlagsAreImplemented ensures every flag defined in commands.yaml
// is actually used in the corresponding handler code.
// This test is auto-generated to prevent flags from being documented but not implemented.
func TestAllFlagsAreImplemented(t *testing.T) {
	// Map of command to handler file and flags that must be used
	commandFlags := map[string]struct {
		handlerPath string
		flags       []string
	}{
		"cleanup": {
			handlerPath: "internal/pkg/cli/handlers/lifecycle/cleanup.go",
			flags: []string{
				"all",
				"force",
				"images",
				"networks",
				"orphans",
				"project",
				"volumes",
			},
		},
		"connect": {
			handlerPath: "internal/pkg/cli/handlers/operations/connect.go",
			flags: []string{
				"database",
				"host",
				"port",
				"read-only",
				"user",
			},
		},
		"doctor": {
			handlerPath: "internal/pkg/cli/handlers/project/doctor.go",
			flags: []string{
				"fix",
				"format",
			},
		},
		"down": {
			handlerPath: "internal/pkg/cli/handlers/lifecycle/down.go",
			flags: []string{
				"all",
				"remove",
				"remove-orphans",
				"shared",
				"timeout",
				"volumes",
			},
		},
		"exec": {
			handlerPath: "internal/pkg/cli/handlers/operations/exec.go",
			flags: []string{
				"detach",
				"env",
				"interactive",
				"tty",
				"user",
				"workdir",
			},
		},
		"init": {
			handlerPath: "internal/pkg/cli/handlers/project/init.go",
			flags: []string{
				"force",
				"no-shared-containers",
				"project-name",
				"services",
				"shared-services",
			},
		},
		"restart": {
			handlerPath: "internal/pkg/cli/handlers/lifecycle/restart.go",
			flags: []string{
				"no-deps",
				"timeout",
			},
		},
		"services": {
			handlerPath: "internal/pkg/cli/handlers/project/services.go",
			flags: []string{
				"category",
				"format",
			},
		},
		"status": {
			handlerPath: "internal/pkg/cli/handlers/operations/status.go",
			flags: []string{
				"all",
				"format",
				"project",
				"shared",
			},
		},
		"up": {
			handlerPath: "internal/pkg/cli/handlers/lifecycle/up.go",
			flags: []string{
				"build",
				"detach",
				"force-recreate",
				"no-deps",
				"timeout",
			},
		},
		"validate": {
			handlerPath: "internal/pkg/cli/handlers/project/validate.go",
			flags: []string{
				"fix",
				"format",
				"strict",
			},
		},
		"version": {
			handlerPath: "internal/pkg/cli/handlers/utility/version.go",
			flags: []string{
				"check-updates",
				"format",
				"full",
			},
		},
		"web-interfaces": {
			handlerPath: "internal/pkg/cli/handlers/utility/web-interfaces.go",
			flags: []string{
				"all",
			},
		},
	}

	for cmdName, info := range commandFlags {
		t.Run(cmdName, func(t *testing.T) {
			// Read handler file
			handlerCode, err := os.ReadFile(info.handlerPath)
			if err != nil {
				t.Skipf("Handler file not found: %s", info.handlerPath)
				return
			}

			code := string(handlerCode)

			// Check each flag is used
			for _, flagName := range info.flags {
				if !isFlagUsedInCode(code, flagName, cmdName) {
					t.Errorf("Flag '%s' defined in commands.yaml but not used in handler", flagName)
				}
			}
		})
	}
}

func isFlagUsedInCode(code, flagName, cmdName string) bool {
	// Check for Parse*Flags usage (preferred pattern)
	parseFuncName := "Parse" + strings.Title(cmdName) + "Flags"
	if strings.Contains(code, parseFuncName) {
		// Using generated parser - assume all flags in struct are used
		return true
	}

	// Check for direct flag access patterns
	pascalFlag := toPascalCase(flagName)
	patterns := []string{
		`GetBool("` + flagName + `")`,
		`GetString("` + flagName + `")`,
		`GetInt("` + flagName + `")`,
		`GetBool(core.Flag` + pascalFlag + `)`,
		`GetString(core.Flag` + pascalFlag + `)`,
		`GetInt(core.Flag` + pascalFlag + `)`,
		`.` + pascalFlag, // Struct field access
	}

	for _, pattern := range patterns {
		if strings.Contains(code, pattern) {
			return true
		}
	}

	return false
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "-")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
