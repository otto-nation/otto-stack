package config

import (
	"fmt"
	"strings"

	"github.com/otto-nation/otto-stack/internal/config"
	"github.com/otto-nation/otto-stack/internal/pkg/constants"
	"github.com/otto-nation/otto-stack/internal/pkg/version"
	"gopkg.in/yaml.v3"
)

// SchemaProperty represents a property in the config schema
type SchemaProperty struct {
	Type        string                    `yaml:"type"`
	Default     interface{}               `yaml:"default"`
	Description string                    `yaml:"description"`
	Enum        []string                  `yaml:"enum,omitempty"`
	Items       *SchemaProperty           `yaml:"items,omitempty"`
	Properties  map[string]SchemaProperty `yaml:"properties,omitempty"`
}

// ConfigSchema represents the complete configuration schema
type ConfigSchema struct {
	Metadata  SchemaMetadata            `yaml:"metadata"`
	Templates map[string]string         `yaml:"templates"`
	Schema    map[string]SchemaProperty `yaml:"schema"`
}

// SchemaMetadata contains schema metadata
type SchemaMetadata struct {
	SchemaVersion string `yaml:"schema_version"`
	GeneratedBy   string `yaml:"generated_by"`
	Description   string `yaml:"description"`
}

// LoadSchema loads the configuration schema
func LoadSchema() (*ConfigSchema, error) {
	data := config.EmbeddedSchemaYAML

	var schema ConfigSchema
	if err := yaml.Unmarshal(data, &schema); err != nil {
		return nil, fmt.Errorf("failed to parse schema: %w", err)
	}

	return &schema, nil
}

// GenerateConfigFromSchema generates a config YAML from schema with defaults
func GenerateConfigFromSchema(projectName string, services []string, overrides map[string]interface{}) (string, error) {
	schema, err := LoadSchema()
	if err != nil {
		return "", err
	}

	var builder strings.Builder

	// Header
	builder.WriteString(fmt.Sprintf(constants.YAMLComment, constants.AppNameTitle+" Configuration"))
	builder.WriteString(fmt.Sprintf(constants.YAMLComment, "Generated for project: "+projectName))
	builder.WriteString(fmt.Sprintf(constants.YAMLComment, "Generated by: "+version.GetFullVersion()))
	builder.WriteString(fmt.Sprintf(constants.YAMLComment, "Documentation: "+constants.ConfigDocsURL))
	builder.WriteString("\n")

	// Generate each section
	for sectionName, sectionSchema := range schema.Schema {
		if sectionName == constants.SectionStack && len(services) > 0 {
			// Special handling for stack.enabled
			builder.WriteString(fmt.Sprintf(constants.YAMLComment, sectionSchema.Description))
			builder.WriteString(fmt.Sprintf(constants.YAMLSection, sectionName))
			builder.WriteString(constants.YAMLEnabled)
			for _, service := range services {
				builder.WriteString(fmt.Sprintf(constants.YAMLListItem, service))
			}
		} else {
			builder.WriteString(fmt.Sprintf(constants.YAMLComment, sectionSchema.Description))
			builder.WriteString(fmt.Sprintf("%s:", sectionName))
			if sectionSchema.Type == constants.YAMLTypeObject {
				builder.WriteString("\n")
				generateSection(&builder, sectionSchema, 1, projectName, overrides)
			} else {
				builder.WriteString(" ")
				generateSection(&builder, sectionSchema, 0, projectName, overrides)
				builder.WriteString("\n")
			}
		}
		builder.WriteString("\n")
	}

	return builder.String(), nil
}

// generateSection recursively generates YAML for a schema section
func generateSection(builder *strings.Builder, schema SchemaProperty, indent int, projectName string, overrides map[string]interface{}) {
	indentStr := strings.Repeat(constants.YAMLIndent, indent)

	switch schema.Type {
	case constants.YAMLTypeObject:
		for propName, propSchema := range schema.Properties {
			if propSchema.Description != "" && indent > 0 {
				fmt.Fprintf(builder, constants.YAMLIndent+constants.YAMLComment, propSchema.Description)
			}

			defaultValue := propSchema.Default
			if defaultValue != nil {
				// Handle template substitution
				if str, ok := defaultValue.(string); ok {
					defaultValue = resolveTemplate(str, projectName)
				}

				fmt.Fprintf(builder, constants.YAMLProperty, indentStr, propName)
				writeValue(builder, defaultValue, propSchema.Type)
				builder.WriteString("\n")
			} else if propSchema.Type == constants.YAMLTypeObject {
				fmt.Fprintf(builder, constants.YAMLProperty+"\n", indentStr, propName)
				generateSection(builder, propSchema, indent+1, projectName, overrides)
			}
		}
	default:
		if schema.Default != nil {
			// Handle template substitution for non-object types
			if str, ok := schema.Default.(string); ok {
				writeValue(builder, resolveTemplate(str, projectName), schema.Type)
			} else {
				writeValue(builder, schema.Default, schema.Type)
			}
		}
	}
}

// resolveTemplate resolves template variables to actual values using a map
func resolveTemplate(template, projectName string) interface{} {
	resolvers := map[string]interface{}{
		constants.TemplateProjectName:             projectName,
		constants.TemplateOttoVersion:             version.GetShortVersion(),
		constants.TemplateConfigDocsURL:           constants.ConfigDocsURL,
		constants.TemplateServiceConfigURL:        constants.ServiceConfigURL,
		constants.TemplateDefaultSkipWarnings:     constants.DefaultSkipWarnings,
		constants.TemplateDefaultAllowMultipleDBs: constants.DefaultAllowMultipleDBs,
		constants.TemplateDefaultAutoStart:        constants.DefaultAutoStart,
		constants.TemplateDefaultPullLatest:       constants.DefaultPullLatestImages,
		constants.TemplateDefaultCleanupRecreate:  constants.DefaultCleanupOnRecreate,
	}

	if value, exists := resolvers[template]; exists {
		return value
	}
	return template
}

// writeValue writes a value in the appropriate YAML format
func writeValue(builder *strings.Builder, value interface{}, valueType string) {
	switch valueType {
	case constants.YAMLTypeBoolean:
		fmt.Fprintf(builder, "%t", value)
	case constants.YAMLTypeArray:
		if arr, ok := value.([]interface{}); ok && len(arr) == 0 {
			builder.WriteString("[]")
		} else {
			fmt.Fprintf(builder, "%v", value)
		}
	case constants.YAMLTypeObject:
		if obj, ok := value.(map[interface{}]interface{}); ok && len(obj) == 0 {
			builder.WriteString("{}")
		} else {
			fmt.Fprintf(builder, "%v", value)
		}
	default:
		fmt.Fprintf(builder, "%v", value)
	}
}
