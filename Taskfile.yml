version: "3"

# ============================================================================
# VARIABLES
# ============================================================================
vars:
  BINARY_NAME: otto-stack
  BUILD_DIR: build
  MODULE_PATH: github.com/otto-nation/otto-stack
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
  COMMIT:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "unknown"
  BUILD_DATE:
    sh: date -u +"%Y-%m-%dT%H:%M:%SZ"
  GO_VERSION:
    sh: go version | cut -d' ' -f3
  BUILD_OS:
    sh: echo "{{OS}}"
  BUILD_ARCH:
    sh: echo "{{ARCH}}"
  LDFLAGS: '-ldflags "-X {{.MODULE_PATH}}/internal/pkg/version.AppVersion={{.VERSION}} -X {{.MODULE_PATH}}/internal/pkg/version.BuildDate={{.BUILD_DATE}} -X {{.MODULE_PATH}}/internal/pkg/version.GitCommit={{.COMMIT}} -X {{.MODULE_PATH}}/internal/pkg/version.BuildBy=taskfile"'
  GOLANGCI_LINT_VERSION: "v2.6.0"

# ============================================================================
# TASKS
# ============================================================================
tasks:
  # ============================================================================
  # DEFAULT
  # ============================================================================
  default:
    desc: "ğŸš€ Build the binary (default task)"
    silent: true
    cmds:
      - task: build

  # ============================================================================
  # SETUP
  # ============================================================================
  setup:
    desc: "ğŸ”§ Install all dependencies (Go modules + npm packages)"
    deps: [setup:go, setup:npm]
    silent: true
    cmds:
      - echo "âœ… All dependencies installed"

  setup:go:
    desc: "ğŸ“¦ Install Go dependencies"
    silent: true
    cmds:
      - echo "ğŸ“¦ Installing Go dependencies..."
      - go mod download

  setup:npm:
    desc: "ğŸ“¦ Install npm dependencies"
    sources:
      - "docs-site/package.json"
      - "docs-site/package-lock.json"
    generates:
      - "docs-site/node_modules/.package-lock.json"
    silent: true
    cmds:
      - echo "ğŸ“¦ Installing npm dependencies..."
      - cd docs-site && npm install

  # ============================================================================
  # GENERATE
  # ============================================================================
  generate:
    desc: "ğŸ”§ Generate code from YAML configs"
    deps: [generate:cli, generate:services]
    silent: true
    cmds:
      - gofmt -w $(find internal -name '*_generated.go')
      - task: generate:docs
      - echo "âœ… Generated code from YAML configs"

  generate:cli:
    desc: "ğŸ”§ Generate CLI code"
    sources:
      - "internal/config/commands.yaml"
      - "cmd/generate-cli/main.go"
      - "cmd/generate-cli/templates/*.tmpl"
    generates:
      - "internal/pkg/cli/commands_generated.go"
    silent: true
    cmds:
      - echo "ğŸ”§ Running generate-cli..."
      - go run ./cmd/generate-cli

  generate:services:
    desc: "ğŸ”§ Generate service code"
    sources:
      - "internal/config/services/**/*.yaml"
      - "cmd/generate-services/main.go"
      - "cmd/generate-services/templates/*.tmpl"
    generates:
      - "internal/pkg/services/services_generated.go"
      - "internal/pkg/services/types_generated.go"
      - "internal/pkg/services/schema_generated.go"
    silent: true
    cmds:
      - echo "ğŸ”§ Running generate-services..."
      - go run ./cmd/generate-services

  generate:docs:
    desc: "ğŸ“š Generate documentation"
    deps: [setup:npm]
    sources:
      - "internal/config/schema.yaml"
      - "internal/config/commands.yaml"
      - "internal/config/services/**/*.yaml"
      - "docs-site/generators/**/*.js"
      - "docs-site/templates/**/*.md"
    generates:
      - "docs-site/content/configuration.md"
      - "docs-site/content/cli-reference.md"
    silent: true
    cmds:
      - echo "ğŸ“š Generating documentation..."
      - cd docs-site && npm run docs:generate

  # ============================================================================
  # BUILD
  # ============================================================================
  build:
    desc: "ğŸ”¨ Build the Go binary for current platform"
    deps: [sync-go-version, generate, lint:go]
    sources:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
    generates:
      - "{{.BUILD_DIR}}/{{.BINARY_NAME}}"
    silent: true
    cmds:
      - echo "ğŸ”¨ Building {{.BINARY_NAME}}..."
      - mkdir -p {{.BUILD_DIR}}
      - go build {{.LDFLAGS}} -o {{.BUILD_DIR}}/{{.BINARY_NAME}} ./cmd/otto-stack
      - echo "âœ… Built at {{.BUILD_DIR}}/{{.BINARY_NAME}}"

  build-all:
    desc: "ğŸŒ Build binaries for all supported platforms"
    deps: [lint]
    silent: true
    cmds:
      - echo "ğŸŒ Building {{.BINARY_NAME}} for all platforms..."
      - mkdir -p {{.BUILD_DIR}}
      - GOOS=linux GOARCH=amd64 go build {{.LDFLAGS}} -o {{.BUILD_DIR}}/{{.BINARY_NAME}}-linux-amd64 ./cmd/otto-stack
      - GOOS=linux GOARCH=arm64 go build {{.LDFLAGS}} -o {{.BUILD_DIR}}/{{.BINARY_NAME}}-linux-arm64 ./cmd/otto-stack
      - GOOS=darwin GOARCH=amd64 go build {{.LDFLAGS}} -o {{.BUILD_DIR}}/{{.BINARY_NAME}}-darwin-amd64 ./cmd/otto-stack
      - GOOS=darwin GOARCH=arm64 go build {{.LDFLAGS}} -o {{.BUILD_DIR}}/{{.BINARY_NAME}}-darwin-arm64 ./cmd/otto-stack
      - GOOS=windows GOARCH=amd64 go build {{.LDFLAGS}} -o {{.BUILD_DIR}}/{{.BINARY_NAME}}-windows-amd64.exe ./cmd/otto-stack
      - echo "âœ… All binaries built in {{.BUILD_DIR}}/"

  install:
    desc: "ğŸ“¦ Install the binary to GOPATH/bin"
    deps: [build]
    silent: true
    cmds:
      - echo "ğŸ“¦ Installing {{.BINARY_NAME}}..."
      - go install {{.LDFLAGS}} ./cmd/otto-stack > /dev/null 2>&1
      - echo "âœ… Installed to $(go env GOPATH)/bin/{{.BINARY_NAME}}"

  # ============================================================================
  # DEVELOPMENT
  # ============================================================================
  dev:
    desc: "ğŸš€ Quick start - build and show help"
    deps: [build]
    silent: true
    cmds:
      - echo "ğŸš€ Running {{.BINARY_NAME}} in development mode..."
      - ./{{.BUILD_DIR}}/{{.BINARY_NAME}} --help

  watch:
    desc: "ğŸ‘€ Watch for changes and rebuild automatically"
    watch: true
    sources:
      - "**/*.go"
    silent: true
    cmds:
      - echo "ğŸ‘€ Rebuilding due to changes..."
      - task: build

  # ============================================================================
  # DEPENDENCIES
  # ============================================================================
  deps:
    desc: "ğŸ“¥ Download and tidy Go dependencies"
    sources:
      - "go.mod"
      - "go.sum"
    silent: true
    cmds:
      - go mod download
      - go mod tidy

  # ============================================================================
  # GIT AUTOMATION
  # ============================================================================
  commit:
    desc: "ğŸ¤– Generate AI-powered commit message based on staged changes"
    silent: true
    deps: [pre-commit]
    cmds:
      - |
        if [ "$NO_VERIFY" ]; then
            echo 'pre-commit hook skipped' 1>&2
            exit 0
        fi
        STAGED_FILES=$(git diff --cached --name-only)
        if [ -z "$STAGED_FILES" ]; then
          echo "âŒ No staged changes found. Use 'git add' first."
          exit 1
        fi

        echo "ğŸ¤– Analyzing staged changes with AI..."

        DIFF_CONTENT=$(git diff --cached --no-color)
        FILE_LIST=$(echo "$STAGED_FILES" | tr '\n' ', ' | sed 's/,$//')
        COMMITLINT_CONFIG=$(cat .github/.commitlintrc.json)

        AI_PROMPT="Generate a conventional commit message following these rules:
        - Header (first line) MUST be â‰¤72 characters. CRITICAL: Count each character including spaces and punctuation.
        - If header approaches 72 chars, use shorter words: 'use' not 'utilize', 'fix' not 'resolve'
        - Prefer short scopes (max 10 chars) and concise descriptions (max 50 chars)
        - Body lines must be â‰¤100 characters each
        - Use conventional commit format: type(scope): description
        - Separate header and body with blank line
        - Use bullet points for multiple changes

        Config: $COMMITLINT_CONFIG

        Files changed: $FILE_LIST

        Diff:
        $DIFF_CONTENT

        Return only the commit message, nothing else."

        source ./scripts/common.sh

        if ! AI_COMMAND=$(check_ai_available 2>&1); then
          echo "$AI_COMMAND"
          exit 1
        fi

        echo "ğŸ¤– Generating commit message..."
        COMMIT_MSG=$(echo "$AI_PROMPT" | $AI_COMMAND | tr -d '\033' | sed 's/\[[0-9;]*m//g' | sed 's/^[> ]*//g')

        # Validate commit message header length
        HEADER=$(echo "$COMMIT_MSG" | head -n1)
        HEADER_LENGTH=${#HEADER}
        if [ $HEADER_LENGTH -gt 72 ]; then
          echo "âŒ Generated header is too long: $HEADER_LENGTH characters (max 72)"
          echo "Header: $HEADER"
          echo ""
          echo "Please manually commit with a shorter message:"
          echo "  git commit"
          exit 1
        fi

        echo "âœ¨ AI Analysis Complete"
        echo ""
        echo "ğŸ“ Generated: $COMMIT_MSG"
        echo "ğŸš€ Committing..."
        git commit -m "$COMMIT_MSG"
        echo "âœ… Committed successfully!"

  pr-content:
    desc: "ğŸ¤– Generate AI-powered PR content"
    internal: true
    silent: true
    cmds:
      - |
        BRANCH=$(git branch --show-current)
        if [ "$BRANCH" = "main" ]; then
          echo "âŒ Cannot create PR from main branch"
          exit 1
        fi

        COMMITS=$(git log --oneline origin/main..HEAD)
        COMMIT_COUNT=$(git rev-list --count origin/main..$BRANCH)
        CHANGED_FILES=$(git diff --name-only origin/main..$BRANCH)
        PR_TEMPLATE=$(cat .github/pull_request_template.md)

        AI_PROMPT="Generate a professional PR title and fill out this template based on the changes:

        Template:
        $PR_TEMPLATE

        Branch: $BRANCH
        Commits: $COMMIT_COUNT

        Recent commits:
        $COMMITS

        Changed files:
        $CHANGED_FILES

        Return: TITLE: <title>
        DESCRIPTION: <filled template>"

        source ./scripts/common.sh

        if ! AI_COMMAND=$(check_ai_available 2>&1); then
          echo "$AI_COMMAND"
          exit 1
        fi

        RAW_RESPONSE=$(echo "$AI_PROMPT" | $AI_COMMAND)
        AI_RESPONSE=$(echo "$RAW_RESPONSE" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' | sed 's/\x1b\[[0-9;]*R//g' | tr -d '\033\007\015' | sed 's/^[> ]*//g')

        PR_TITLE=$(echo "$AI_RESPONSE" | grep "^TITLE:" | sed 's/^TITLE: //' | head -1 | tr -d '\n\r')
        PR_DESCRIPTION=$(echo "$AI_RESPONSE" | sed -n '/^DESCRIPTION:/,$ p' | sed '1d' | sed 's/^```$//' | sed 's/^```$//')

        if [ -z "$PR_TITLE" ]; then PR_TITLE="feat: improve codebase"; fi
        if [ -z "$PR_DESCRIPTION" ]; then PR_DESCRIPTION="## Summary\n\nBranch: $BRANCH\nCommits: $COMMIT_COUNT"; fi

        mkdir -p /tmp/task-pr
        echo "$PR_TITLE" > /tmp/task-pr/title
        echo "$PR_DESCRIPTION" > /tmp/task-pr/description

        echo "ğŸ“ Title: $PR_TITLE"
        echo "ğŸ“„ Description:"
        echo "$PR_DESCRIPTION"

  create-pr:
    desc: "ğŸ¤– Create AI-powered pull request with smart title and description"
    silent: true
    cmds:
      - |
        BRANCH=$(git branch --show-current)

        # Check if remote branch exists
        if git ls-remote --heads origin $BRANCH | grep -q $BRANCH; then
          # Remote exists, check for divergence
          git fetch origin $BRANCH --quiet

          LOCAL=$(git rev-parse @)
          REMOTE=$(git rev-parse @{u})
          BASE=$(git merge-base @ @{u})

          if [ "$LOCAL" = "$REMOTE" ]; then
            echo "âœ… Branch is up to date with remote"
          elif [ "$LOCAL" = "$BASE" ]; then
            echo "âš ï¸  Remote has commits not in local branch"
            echo "âŒ Cannot create PR - please pull first: git pull"
            exit 1
          elif [ "$REMOTE" = "$BASE" ]; then
            echo "ğŸ“¤ Local has unpushed commits, pushing..."
            git push origin $BRANCH
          else
            echo "âŒ Branch has diverged from remote"
            echo "ğŸ’¡ Fix with: git pull --rebase or git reset"
            exit 1
          fi
        else
          # Remote doesn't exist, push it
          echo "ğŸ“¤ Pushing new branch to remote..."
          git push -u origin $BRANCH
        fi

        echo "ğŸ¤– Analyzing branch changes with AI: $BRANCH"
      - task: pr-content
      - |
        PR_TITLE=$(cat /tmp/task-pr/title)
        PR_DESCRIPTION=$(cat /tmp/task-pr/description)

        echo "âœ¨ AI Analysis Complete"
        echo "ğŸš€ Creating PR..."

        PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_DESCRIPTION" --assignee @me 2>&1 | grep -o 'https://github.com[^[:space:]]*' || echo "")

        echo "âœ… Pull request created!"
        if [ -n "$PR_URL" ]; then echo "ğŸ”— View: $PR_URL"; fi

  update-pr:
    desc: "ğŸ”„ Update current PR description with AI-generated content"
    silent: true
    cmds:
      - |
        BRANCH=$(git branch --show-current)
        if [ "$BRANCH" = "main" ]; then
          echo "âŒ Cannot update PR from main branch"
          exit 1
        fi

        echo "ğŸ” Checking for existing PR..."
        PR_NUMBER=$(gh pr view --json number -q .number 2>/dev/null)

        if [ -z "$PR_NUMBER" ]; then
          echo "âŒ No PR found for branch: $BRANCH"
          echo "ğŸ’¡ Use 'task create-pr' to create a new PR"
          exit 1
        fi

        echo "ğŸ¤– Analyzing branch changes with AI: $BRANCH"
      - task: pr-content
      - |
        PR_DESCRIPTION=$(cat /tmp/task-pr/description)
        PR_NUMBER=$(gh pr view --json number -q .number 2>/dev/null)

        echo "âœ¨ AI Analysis Complete"
        echo "ğŸ”„ Updating PR #$PR_NUMBER..."

        gh pr edit $PR_NUMBER --body "$PR_DESCRIPTION"

        echo "âœ… PR description updated!"
        echo "ğŸ”— View: $(gh pr view --json url -q .url)"

  pre-commit:
    desc: "ğŸ”’ Run all pre-commit checks"
    silent: true
    cmds:
      - echo "ğŸ”’ Running pre-commit checks..."
      - task: generate
      - |
        echo "ğŸ”§ Auto-fixing formatting and modules..."
        CHANGES_MADE=false

        # Check if generated files need formatting
        git diff --quiet && BEFORE_FMT_CLEAN=true || BEFORE_FMT_CLEAN=false
        task fmt
        if [ "$BEFORE_FMT_CLEAN" = "true" ] && ! git diff --quiet; then
          echo "âŒ Formatting changes detected"
          CHANGES_MADE=true
        fi

        # Check if go mod tidy makes changes
        git diff --quiet && BEFORE_MOD_CLEAN=true || BEFORE_MOD_CLEAN=false
        go mod tidy
        if [ "$BEFORE_MOD_CLEAN" = "true" ] && ! git diff --quiet; then
          echo "âŒ Go module changes detected"
          CHANGES_MADE=true
        fi

        if [ "$CHANGES_MADE" = "true" ]; then
          echo ""
          echo "ğŸ“‹ Modified files:"
          git diff --name-only | sed 's/^/  - /'
          echo ""
          echo "ğŸ”§ Please stage these changes and commit again:"
          echo "   git add <files>"
          echo "   git commit"
          echo ""
          exit 1
        fi
      - echo "âœ… Verifying fixes..."
      - task: lint
      - echo "âœ… Pre-commit checks passed"

  pre-push:
    desc: "ğŸš€ Run all pre-push checks"
    deps: [build, test]
    silent: true
    cmds:
      - echo "ğŸš€ Running pre-push checks..."
      - task: validate:commits
      - task: deadcode
      - task: docs
      - |
        # Check if docs generation made any changes
        if ! git diff --quiet; then
          echo ""
          echo "âŒ Pre-push failed: Documentation was out of sync"
          echo ""
          echo "ğŸ“‹ Modified files:"
          git diff --name-only
          echo ""
          echo "ğŸ”§ Please add these changes and commit again:"
          echo "   git add ."
          echo "   git commit"
          echo ""
          exit 1
        fi
      - echo "âœ… Pre-push checks passed"

  docs-lastmod-update:
    desc: "ğŸ—“ï¸ Update lastmod dates for changed documentation files"
    sources:
      - "docs-site/content/**/*.md"
    silent: true
    cmds:
      - ./scripts/update-docs-lastmod.sh

  setup-hooks:
    desc: "ğŸª Install Git hooks for pre-commit and pre-push checks"
    sources:
      - "scripts/setup-hooks.sh"
      - ".git/hooks/*"
    silent: true
    cmds:
      - ./scripts/setup-hooks.sh

  sync-go-version:
    desc: "ğŸ”„ Sync Go version across all configuration files"
    sources:
      - ".go-version"
      - ".github/workflows/*.yml"
      - "Dockerfile"
      - "go.mod"
    silent: true
    cmds:
      - ./scripts/go-version.sh sync --fix
      - GOTOOLCHAIN=local go mod tidy

  check-go-version:
    desc: "âœ… Check if Go versions are consistent across files"
    sources:
      - ".go-version"
      - ".github/workflows/*.yml"
      - "Dockerfile"
      - "go.mod"
    silent: true
    cmds:
      - ./scripts/go-version.sh sync --check

  # ============================================================================
  # TESTING
  # ============================================================================
  test:
    desc: "ğŸ§ª Run all tests with coverage"
    deps: [test-unit]
    silent: true
    cmds:
      - echo "âœ… Coverage report at coverage.out"

  test-unit:
    desc: "ğŸ§ª Run unit tests only (fast)"
    deps: [deps]
    sources:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
    generates:
      - "coverage.out"
    cmds:
      - echo "ğŸ§ª Running unit tests..."
      - |
        if [ "${CGO_ENABLED:-1}" = "0" ]; then
          go test -v -tags=unit -coverprofile=coverage.out -covermode=atomic ./internal/...
        else
          go test -v -race -tags=unit -coverprofile=coverage.out -covermode=atomic ./internal/...
        fi
      - echo "âœ… Unit tests passed"

  test-e2e:
    desc: "ğŸ”— Run end-to-end integration tests only"
    deps: [deps]
    preconditions:
      - sh: docker info
        msg: "Docker is required for E2E tests"
    cmds:
      - echo "ğŸ”— Running E2E integration tests..."
      - go test -tags=integration -v -timeout=10m -parallel=1 -count=1 ./test/e2e/... | tee

  test-coverage:
    desc: "ğŸ“Š View test coverage report in browser"
    deps: [test]
    silent: true
    cmds:
      - echo "ğŸ“Š Opening coverage report..."
      - go tool cover -html=coverage.out

  lint:
    desc: "ğŸ” Run comprehensive linting (vet + fmt + golangci-lint)"
    deps: [lint:go]
    sources:
      - "**/*.go"
      - ".golangci.yml"
      - "go.mod"
      - "go.sum"
    silent: true
    cmds:
      - task: lint:docs
      - echo "âœ… All linting checks passed!"

  lint:go:
    desc: "ğŸ” Run Go-only linting (vet + golangci-lint) - for CI"
    deps: [deps, fmt]
    sources:
      - "**/*.go"
      - ".golangci.yml"
      - "go.mod"
      - "go.sum"
    silent: true
    cmds:
      - mkdir -p .task
      - go vet ./...
      - |
        GOLANGCI_PATH="$(go env GOPATH)/bin/golangci-lint"
        EXPECTED_VERSION="{{.GOLANGCI_LINT_VERSION}}"

        if [ ! -f "$GOLANGCI_PATH" ]; then
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin $EXPECTED_VERSION > /dev/null 2>&1
        else
          CURRENT_VERSION="v$($GOLANGCI_PATH version 2>/dev/null | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' | head -1 || echo "unknown")"
          if [ "$CURRENT_VERSION" != "$EXPECTED_VERSION" ]; then
            curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin $EXPECTED_VERSION > /dev/null 2>&1
          fi
        fi

        $GOLANGCI_PATH config verify
        $GOLANGCI_PATH run ./cmd/otto-stack/... ./internal/...
      - |
        # Verify code compiles (catches unused imports in generated code)
        go build -o /dev/null ./cmd/otto-stack
      - touch .task/go-lint-timestamp

  lint:docs:
    desc: "ğŸ“ Lint documentation files"
    sources:
      - "docs-site/content/**/*.md"
      - "docs-site/README.md"
      - "docs-site/.markdownlint.jsonc"
      - "docs-site/.mlc_config.json"
    silent: true
    cmds:
      - echo "ğŸ“ Linting documentation..."
      - |
        cd docs-site
        # Run markdown lint and link check in parallel
        npm run lint:md &
        LINT_PID=$!
        npm run lint:links &
        LINKS_PID=$!

        # Wait for both to complete
        wait $LINT_PID
        LINT_EXIT=$?
        wait $LINKS_PID
        LINKS_EXIT=$?

        # Check if either failed
        if [ $LINT_EXIT -ne 0 ] || [ $LINKS_EXIT -ne 0 ]; then
          echo "âŒ Documentation linting failed"
          exit 1
        fi

  fmt:
    desc: "âœ¨ Format Go code with gofmt and goimports"
    sources:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
    silent: true
    cmds:
      - |
        if [ ! -f $(go env GOPATH)/bin/goimports ]; then
          go install golang.org/x/tools/cmd/goimports@latest > /dev/null 2>&1
        fi
      - go fmt ./... > /dev/null 2>&1
      - $(go env GOPATH)/bin/goimports -w . > /dev/null 2>&1

  security:
    desc: "ğŸ”’ Run security vulnerability scan"
    deps: [deps]
    sources:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
    silent: true
    cmds:
      - echo "ğŸ”’ Running security scan..."
      - |
        # Install security tools if needed
        if ! command -v govulncheck >/dev/null 2>&1; then
          echo "ğŸ“¦ Installing govulncheck..."
          go install golang.org/x/vuln/cmd/govulncheck@latest
        fi
      - echo "ğŸ” Running vulnerability scan..."
      - govulncheck ./...
      - echo "ğŸ” Running basic security checks..."
      - |
        # Check for hardcoded secrets patterns (excluding test files and generated code)
        if grep -r -E "(password|pwd|secret|key|token)\s*[:=]\s*['\"][^'\"]{8,}" --include="*.go" --exclude="*_test.go" --exclude="*_generated.go" . ; then
          echo "âš ï¸ Potential hardcoded secrets found"
          exit 1
        fi

        echo "âœ… Basic security checks passed"
      - echo "âœ… Security scan complete"

  deadcode:
    desc: "ğŸ” Check for unreachable code (informational by default, strict with DEADCODE_STRICT=true)"
    sources:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
    silent: true
    cmds:
      - echo "ğŸ” Checking for dead code..."
      - |
        # Run deadcode analysis
        # Note: Deadcode tool reports functions as unreachable if they're only called from:
        # - Test code (test helpers, mocks, DI constructors)
        # - Excluded packages (e2e framework, code generators)
        # - Future features not yet exposed via CLI
        DEADCODE_OUTPUT=$(go run golang.org/x/tools/cmd/deadcode@latest ./... 2>&1)
        
        if [ -n "$DEADCODE_OUTPUT" ]; then
          # Filter out acceptable dead code:
          # - test helpers and e2e framework
          # - code generators (cmd/codegen, cmd/generate-*)
          # - internal/cli (old CLI code being phased out)
          FILTERED=$(echo "$DEADCODE_OUTPUT" | \
            grep -v "test/e2e/framework" | \
            grep -v "test/testhelpers" | \
            grep -v "test/testutil" | \
            grep -v "cmd/codegen" | \
            grep -v "cmd/generate-services" | \
            grep -v "internal/cli/root_factory.go" || true)
          
          if [ -n "$FILTERED" ]; then
            DEADCODE_COUNT=$(echo "$FILTERED" | wc -l | tr -d ' ')
            echo "â„¹ï¸  Found $DEADCODE_COUNT unreachable functions"
            
            if [ "${DEADCODE_STRICT:-false}" = "true" ]; then
              echo ""
              echo "âš ï¸  Dead code detected (strict mode):"
              echo "$FILTERED"
              echo ""
              echo "ğŸ’¡ Review DEAD_CODE_AUDIT.md for analysis"
              exit 1
            else
              echo "ğŸ’¡ Run 'DEADCODE_STRICT=true task deadcode' to see details"
              echo "   Or review DEAD_CODE_AUDIT.md for full analysis"
            fi
          else
            echo "âœ… No dead code found"
          fi
        else
          echo "âœ… No dead code found"
        fi

  # ============================================================================
  # VALIDATION
  # ============================================================================
  validate:
    desc: "âœ… Run all validation checks"
    deps: [validate:code, validate:docs, validate:homebrew]
    silent: true
    cmds:
      - echo "âœ… All validation checks passed"

  validate:code:
    desc: "âœ… Validate Go code (lint + test)"
    sources:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
      - ".golangci.yml"
    silent: true
    cmds:
      - echo "ğŸ” Validating Go code..."
      - task: lint:go
      - task: test
      - echo "âœ… Code validation passed"

  validate:docs:
    desc: "âœ… Validate documentation (Hugo build + linting)"
    deps: [setup:npm]
    sources:
      - "docs-site/content/**/*.md"
      - "docs-site/config/**/*"
      - "docs-site/generators/**/*.js"
      - "docs-site/templates/**/*.md"
    silent: true
    cmds:
      - echo "ğŸ” Validating documentation..."
      - cd docs-site && hugo --gc --minify --destination public-test
      - cd docs-site && rm -rf public-test
      - echo "âœ… Hugo build successful"
      - task: lint:docs

  validate:homebrew:
    desc: "ğŸº Validate Homebrew formula syntax and style"
    sources:
      - "Formula/otto-stack.rb"
    silent: true
    status:
      - test ! -f "Formula/otto-stack.rb"
      - test ! command -v brew >/dev/null 2>&1
    cmds:
      - echo "ğŸº Validating Homebrew formula..."
      - ruby -c Formula/otto-stack.rb
      - echo "âœ… Homebrew formula syntax valid"

  validate:commits:
    desc: "ğŸ“ Validate commit message lengths"
    silent: true
    cmds:
      - |
        echo "ğŸ“ Validating commit messages..."
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        INVALID_COMMITS=$(git log --oneline origin/$BRANCH..HEAD --format="%h %s" 2>/dev/null | while read sha msg; do
          if [ ${#msg} -gt 72 ]; then
            echo "$sha: $msg (${#msg} chars)"
          fi
        done)

        if [ -n "$INVALID_COMMITS" ]; then
          echo ""
          echo "âŒ Commit headers exceed 72 characters"
          echo ""
          echo "Invalid commits:"
          echo "$INVALID_COMMITS"
          echo ""
          echo "ğŸ”§ Fix with: git rebase -i origin/$BRANCH"
          echo "   Then reword the commit messages to be â‰¤72 characters"
          exit 1
        fi
        echo "âœ… All commit messages valid"

  # ============================================================================
  # DOCUMENTATION
  # ============================================================================
  docs:
    desc: "ğŸ“š Generate and serve documentation"
    deps: [generate:docs]
    silent: true
    cmds:
      - echo "âœ… Documentation generated"

  docs-serve:
    desc: "ğŸŒ Serve documentation locally"
    deps: [generate:docs]
    silent: true
    cmds:
      - echo "ğŸŒ Starting documentation server..."
      - cd docs-site && npm run docs:serve

  # ============================================================================
  # DOCKER
  # ============================================================================
  docker-build:
    desc: "ğŸ³ Build Docker image"
    deps: [build]
    silent: true
    cmds:
      - echo "ğŸ³ Building Docker image..."
      - docker build -t {{.BINARY_NAME}}:{{.VERSION}} .
      - echo "âœ… Docker image built at {{.BINARY_NAME}}:{{.VERSION}}"

  docker-run:
    desc: "ğŸ³ Run Docker container interactively"
    deps: [docker-build]
    silent: true
    cmds:
      - echo "ğŸ³ Running Docker container..."
      - docker run --rm -it {{.BINARY_NAME}}:{{.VERSION}}

  # ----------------------------------------------------------------------------
  # CLEANUP
  # ----------------------------------------------------------------------------
  clean:
    desc: "ğŸ§¹ Remove build artifacts and generated files"
    silent: true
    cmds:
      - echo "ğŸ§¹ Cleaning build artifacts..."
      - rm -rf {{.BUILD_DIR}}/
      - rm -f coverage.out *.test *.prof
      - rm -f .deps-timestamp .lint-timestamp .fmt-timestamp .docs-fmt-timestamp
      - echo "ğŸ§¹ Cleaning generated code..."
      - find internal/ -name '*_generated.go' -type f -delete
      - echo "ğŸ§¹ Cleaning Go build cache..."
      - go clean -cache
      - echo "ğŸ“š Cleaning documentation..."
      - cd docs-site && npm run docs:clean
      - echo "âœ… Clean complete"

  clean-all:
    desc: "ğŸ§¹ Deep clean - remove all generated files including dependencies"
    deps: [clean]
    silent: true
    cmds:
      - echo "ğŸ§¹ Deep cleaning..."
      - go clean -modcache
      - rm -rf vendor/
      - echo "âœ… Deep clean complete"

  # ----------------------------------------------------------------------------
  # UTILITY
  # ----------------------------------------------------------------------------
  version:
    desc: "â„¹ï¸  Show version information"
    silent: true
    cmds:
      - echo "ğŸ“‹ Version Information:"
      - echo "   Version:" {{.VERSION}}
      - echo "   Commit:"  {{.COMMIT}}
      - echo "   Date:"    {{.BUILD_DATE}}

  help:
    desc: "â“ Show this help message"
    silent: true
    cmds:
      - echo "ğŸ› ï¸  otto-stack Task Runner"
      - echo ""
      - echo "ğŸ“‹ Quick Start:"
      - echo "   task build     - Build the binary"
      - echo "   task dev       - Build and run"
      - echo "   task test      - Run tests"
      - echo "   task lint      - Check code quality"
      - echo ""
      - echo "ğŸ”¨ Build Tasks:"
      - echo "   build          - Build binary for current platform"
      - echo "   build-all      - Build for all platforms"
      - echo "   install        - Install to GOPATH/bin"
      - echo ""
      - echo "ğŸš€ Development:"
      - echo "   dev            - Quick start (build + help)"
      - echo "   watch          - Auto-rebuild on changes"
      - echo ""
      - echo "ğŸ§ª Testing:"
      - echo "   test           - Run all tests with coverage"
      - echo "   test-unit      - Run unit tests only (fast)"
      - echo "   test-e2e       - Run end-to-end tests only"
      - echo "   test-coverage  - View coverage in browser"
      - echo ""
      - echo "ğŸ” Quality:"
      - echo "   lint           - Run all linting checks"
      - echo "   fmt            - Format code"
      - echo "   security       - Security vulnerability scan"
      - echo "   deadcode       - Check for unreachable code"
      - echo ""
      - echo "ğŸ“š Documentation:"
      - echo "   docs           - Generate documentation"
      - echo "   docs-serve     - Serve documentation locally"
      - echo ""
      - echo "ğŸ³ Docker:"
      - echo "   docker-build   - Build Docker image"
      - echo "   docker-run     - Run in container"
      - echo ""
      - echo "ğŸ§¹ Cleanup:"
      - echo "   clean          - Remove build artifacts"
      - echo "   clean-all      - Deep clean everything"
      - echo ""
      - echo "ğŸ› ï¸ Development:"
      - echo "   setup-hooks    - Install Git hooks"
      - echo "   sync-go-version - Sync Go version across config files"
      - echo "   check-go-version - Check Go version consistency"
      - echo "   deps           - Update dependencies"
      - echo ""
      - echo "â„¹ï¸  Info:"
      - echo "   version        - Show version info"
      - echo "   help           - Show this help"
      - echo ""
      - echo "ğŸ¤– AI-Powered Git Automation:"
      - echo "   commit         - AI-generated commit messages"
      - echo "   create-pr      - AI-generated PR title/description"
      - echo "   push-and-pr    - Push branch and create AI PR"
      - echo "   pre-commit     - Run all pre-commit checks"
      - echo "   pre-push       - Run all pre-push checks"
      - echo ""
      - echo "ğŸ’¡ Examples:"
      - echo "   task build && ./build/otto-stack --help"
      - echo "   task watch  (Auto-rebuild on file changes)"
      - echo "   task test && task lint"
      - echo ""
      - echo "For detailed task list:" "task --list"
